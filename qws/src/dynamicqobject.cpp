/////////////////////////////////////////////////////////////////////////////
//      
//      File      : dynamicqobject.cpp
//      Copyright : (c) David Harley 2010
//      Project   : qtHaskell
//      Version   : 1.1.4
//      Modified  : 2010-09-02 17:01:54
//      
//      Warning   : this file is machine generated - do not modify.
//      
/////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include "dynamicqobject.h"

#if QT_VERSION >= 0x040600

static const uint qt_meta_data_DynamicQObject[] = {

 // content:
       4,       // revision
       0,       // classname
       0,    0, // classinfo
      96,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
      96,       // signalCount

 // signals: signature, parameters, type, tag, flags
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,
      16,    15,   15,   15, 0x05,

       0        // eod
};

static const char qt_meta_stringdata_DynamicQObject[] = {
    "DynamicQObject\0\0_()\0_(int)\0_(bool)\0_(QString)\0_(QObject*)\0_(QObject*)\0"
};

const QMetaObject DynamicQObject::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_DynamicQObject,
      qt_meta_data_DynamicQObject, 0 }
};

#ifdef Q_NO_DATA_RELOCATION
const QMetaObject &DynamicQObject::getStaticMetaObject() { return staticMetaObject; }
#endif //Q_NO_DATA_RELOCATION

const QMetaObject *DynamicQObject::metaObject() const
{
   QMetaObject * tdmo;
   if (dmo) {
			tdmo = dmo;
   } else {
      tdmo = QObject:: d_ptr->metaObject ? (QMetaObject*)QObject::d_ptr->metaObject :
                                           (QMetaObject*)&staticMetaObject;
   }
   return (const QMetaObject*)tdmo;
}

void *DynamicQObject::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_DynamicQObject))
        return static_cast<void*>(const_cast< DynamicQObject*>(this));
    return QObject::qt_metacast(_clname);
}

static int sigTypeStringOffsets[] = {16, 20, 27, 35, 46, 58};

int signalType (QByteArray * theSignal) {
  int st = 5;
	if (theSignal->endsWith("()")) {
		st = 0;
	}
  else if (theSignal->endsWith("(int)")) {
		st = 1;
	}
	else if (theSignal->endsWith("(bool)")) {
		st = 2;
	}
	else if (theSignal->endsWith("(QString)")) {
		st = 3;
	}
	else if (!theSignal->endsWith("*)")) {
		st = 4;
	}
	return st;
}

void DynamicQObject::setDmoSignal(int signalId, int sigType)
{
  const uint * ddata = dmo->d.data;
  int methodOffset = (int)ddata[5];
  int currentMethodOffset = methodOffset+(signalId*5);
  uint * tui = (uint*)(ddata + currentMethodOffset);
  *tui = (uint)sigTypeStringOffsets[sigType];
}

void DynamicQObject::setDynamicMetaObject(int signalId, int sigType)
{
	if (!dmo) {
		int dm_sz = 15 + (NUMSIGS * 5);
		uint * tmd = new uint[dm_sz];
		memcpy(tmd, qt_meta_data_DynamicQObject, dm_sz * sizeof(uint));
		dmo = new QMetaObject;
    QMetaObject tmo = {{&QObject::staticMetaObject,
			qt_meta_stringdata_DynamicQObject,
			tmd, 0}};
    *dmo = tmo;
	}
	setDmoSignal(signalId, sigType);
}
#endif

bool DynamicQObject::connectDynamicSlot(DynamicQObject *obj, char *signal, char *slot, Qt::ConnectionType contyp, void *rf_ptr, void *stptr, void* qpp)
{
	QByteArray theSignal = QMetaObject::normalizedSignature(signal);
	QByteArray theSlot = QMetaObject::normalizedSignature(slot);
	QObject * ti = (QObject *)obj;
	QObject * to = (QObject *)this;
	if (!QMetaObject::checkConnectArgs(theSignal, theSlot)) {
		return false;
	}
	int signalId = ti->metaObject()->indexOfSignal(theSignal);
	if (signalId < 0) {
		if (((QObject *)ti)->property(QTC_PROP).isValid()) {
			signalId = obj->signalIndices.value(theSignal, -1);
			if (signalId < 0) {
				QObject * tp = (QObject *)(((QObject *)ti)->parent());
				int tsi = tp->metaObject()->indexOfSignal(theSignal);
				if (tsi >= 0) {
					ti = tp;
					signalId = tsi;
				}
				else {
					signalId = obj->signalIndices.size() + obj->slotList.size();
					obj->signalIndices[theSignal] = signalId;
					obj->ssList.append(-1);
#if QT_VERSION >= 0x040600
          obj->setDynamicMetaObject(signalId, signalType(&theSignal));
#endif
					signalId += obj->metaObject()->methodCount() - NUMSIGS;
				}
			}
			else {
				signalId += obj->metaObject()->methodCount() - NUMSIGS;
			}
		}
		else {
			return false;
		}
	}
	int slotId = metaObject()->indexOfSlot(theSlot);
	if (slotId < 0) {
		if (((QObject *)to)->property(QTC_PROP).isValid()) {
			slotId = slotIndices.value(theSlot, -1);
			if (slotId < 0) {
				if (rf_ptr == NULL) {
					QObject * tp = (QObject *)(((QObject *)to)->parent());
					int tsi = tp->metaObject()->indexOfSlot(theSlot);
					if (tsi >= 0) {
						to = tp;
						slotId = tsi;
					}
					else {
						return false;
					}
				}
				else {
					slotId = slotList.size() + signalIndices.size();
					slotIndices[theSlot] = slotId;
					slotList.append(createSlot(&theSlot, qpp, rf_ptr, stptr));
					ssList.append(slotList.size() - 1);
#if QT_VERSION >= 0x040600
					setDynamicMetaObject(slotId, signalType(&theSlot));
#endif
					slotId += metaObject()->methodCount() - NUMSIGS;
				}
			}
			else {
				if (rf_ptr != NULL) {
					slotList[ssList[slotId]]->update(rf_ptr, stptr, slotId);
				}
				slotId += metaObject()->methodCount() - NUMSIGS;
			}
    }
		else {
			return false;
		}
	}
  else if (rf_ptr != NULL) {
			return false;
	}
	return QMetaObject::connect(ti, signalId, to, slotId, contyp);
}

bool DynamicQObject::connectDynamicSignal(char *signal, DynamicQObject *obj, char *slot, Qt::ConnectionType contyp)
{
	QByteArray theSignal = QMetaObject::normalizedSignature(signal);
	QByteArray theSlot = QMetaObject::normalizedSignature(slot);
	QObject * ti = (QObject *)this;
	QObject * to = (QObject *)obj;
	if (!QMetaObject::checkConnectArgs(theSignal, theSlot)) {
		return false;
	}
	int signalId = metaObject()->indexOfSignal(theSignal);
	if (signalId < 0) {
		if (((QObject *)ti)->property(QTC_PROP).isValid()) {
			signalId = signalIndices.value(theSignal, -1);
			if (signalId < 0) {
				QObject * tp = (QObject *)(((QObject *)ti)->parent());
				int tsi = tp->metaObject()->indexOfSignal(theSignal);
				if (tsi >= 0) {
					ti = tp;
					signalId = tsi;
				}
				else {
					signalId = signalIndices.size() + slotList.size();
					signalIndices[theSignal] = signalId;
					ssList.append(-1);
#if QT_VERSION >= 0x040600
					setDynamicMetaObject(signalId, signalType(&theSignal));
#endif
					signalId += metaObject()->methodCount() - NUMSIGS;
				}
			}
			else {
				signalId += metaObject()->methodCount() - NUMSIGS;
			}
		}
		else {
			return false;
		}
	}
	int slotId = obj->metaObject()->indexOfSignal(theSlot);
	if (slotId < 0) {
		if (((QObject *)to)->property(QTC_PROP).isValid()) {
			slotId = obj->signalIndices.value(theSlot, -1);
			if (slotId < 0) {
				QObject * tp = (QObject *)(((QObject *)to)->parent());
				int tsi = tp->metaObject()->indexOfSignal(theSlot);
				if (tsi >= 0) {
					to = tp;
					slotId = tsi;
				}
				else {
					slotId = obj->signalIndices.size() + obj->slotList.size();
					obj->signalIndices[theSlot] = slotId;
					obj->ssList.append(-1);
#if QT_VERSION >= 0x040600
					obj->setDynamicMetaObject(slotId, signalType(&theSlot));
#endif
					slotId += obj->metaObject()->methodCount() - NUMSIGS;
				}
			}
			else {
				slotId += obj->metaObject()->methodCount() - NUMSIGS;
			}
		}
		else {
			return false;
		}
	}
	return QMetaObject::connect(ti, signalId, to, slotId, contyp);
}

int DynamicQObject::qt_metacall(QMetaObject::Call c, int id, void **arguments)
{
	id = QObject::qt_metacall(c, id, arguments);
	if (id < 0 || c != QMetaObject::InvokeMetaMethod) {
		return id;
	}
	if (id >= ssList.size()) {
		return id;
	}
	int tssid = ssList[id];
	if (tssid != -1) {
		slotList[tssid]->call(arguments, id);
	}
	else {
		#if QT_VERSION >= 0x040600
			QMetaObject::activate(this, metaObject(), id + metaObject()->methodCount() - metaObject()->methodOffset() - NUMSIGS, arguments);
		#else
			QMetaObject::activate(this, metaObject(), id + metaObject()->methodCount() - NUMSIGS, arguments);
		#endif
	}	
	return -1;
}

bool DynamicQObject::emitDynamicSignal(char *signal, void **arguments)
{
	QByteArray theSignal = QMetaObject::normalizedSignature(signal);
	int signalId = signalIndices.value(theSignal, -1);
	if (signalId >= 0) {
		#if QT_VERSION >= 0x040600
			QMetaObject::activate(this, metaObject(), signalId + metaObject()->methodCount() - metaObject()->methodOffset() - NUMSIGS, arguments);
		#else
			QMetaObject::activate(this, metaObject(), signalId + metaObject()->methodCount() - NUMSIGS, arguments);
		#endif
		return true;
	}
	else {
		return false;
	}
}

bool DynamicQObject::disconnectDynamicSlot_sos(DynamicQObject *obj, char *signal, char *slot)
{
	QByteArray theSignal = QMetaObject::normalizedSignature(signal);
	QByteArray theSlot = QMetaObject::normalizedSignature(slot);
	QObject * ti = (QObject *)obj;
	QObject * to = (QObject *)this;
	if (!QMetaObject::checkConnectArgs(theSignal, theSlot)) {
		return false;
	}
	int signalId = ti->metaObject()->indexOfSignal(theSignal);
	if (signalId < 0) {
		if (((QObject *)ti)->property(QTC_PROP).isValid()) {
			signalId = obj->signalIndices.value(theSignal, -1);
			if (signalId < 0) {
				QObject * tp = (QObject *)(((QObject *)ti)->parent());
				int tsi = tp->metaObject()->indexOfSignal(theSignal);
				if (tsi >= 0) {
					ti = tp;
					signalId = tsi;
				}
				else {
					return false;
				}
			}
			else {
				signalId += obj->metaObject()->methodCount();
			}
		}
		else {
			return false;
		}
	}
	int slotId = metaObject()->indexOfSlot(theSlot);
	if (slotId < 0) {
	slotId = metaObject()->indexOfSignal(theSlot);
	if (slotId < 0) {
		if (((QObject *)to)->property(QTC_PROP).isValid()) {
			slotId = slotIndices.value(theSlot, -1);
			if (slotId < 0) {
			slotId = signalIndices.value(theSlot, -1);
			if (slotId < 0) {
				QObject * tp = (QObject *)(((QObject *)to)->parent());
				int tsi = tp->metaObject()->indexOfSlot(theSlot);
				if (tsi >= 0) {
					to = tp;
					slotId = tsi;
				}
				else {
					int tsi = tp->metaObject()->indexOfSignal(theSlot);
					if (tsi >= 0) {
						to = tp;
						slotId = tsi;
					}
					else {
						return false;
					}
				}
			}
			else {
				slotId += metaObject()->methodCount();
			}
			}
			else {
				slotId += metaObject()->methodCount();
			}
    }
		else {
			return false;
		}
	}
	}
	return QMetaObject::disconnect(ti, signalId, to, slotId);
}

bool DynamicQObject::disconnectDynamicSlot_so(DynamicQObject *obj, char *signal)
{
	QByteArray theSignal = QMetaObject::normalizedSignature(signal);
	QObject * ti = (QObject *)obj;
	QObject * to = (QObject *)this;
	int signalId = ti->metaObject()->indexOfSignal(theSignal);
	if (signalId < 0) {
		if (((QObject *)ti)->property(QTC_PROP).isValid()) {
			signalId = obj->signalIndices.value(theSignal, -1);
			if (signalId < 0) {
				QObject * tp = (QObject *)(((QObject *)ti)->parent());
				int tsi = tp->metaObject()->indexOfSignal(theSignal);
				if (tsi >= 0) {
					ti = tp;
					signalId = tsi;
				}
				else {
					return false;
				}
			}
			else {
				signalId += obj->metaObject()->methodCount();
			}
		}
		else {
			return false;
		}
	}
	bool tb = QMetaObject::disconnect(ti, signalId, to, -1);
	if (((QObject *)to)->property(QTC_PROP).isValid()) {
		to = (QObject *)(((QObject *)to)->parent());
		tb |= QMetaObject::disconnect(ti, signalId, to, -1);
	}
	return tb;
}

bool DynamicQObject::disconnectDynamicSlot_s(char *signal)
{
	QByteArray theSignal = QMetaObject::normalizedSignature(signal);
	QObject * ti = (QObject *)this;
	int signalId = ti->metaObject()->indexOfSignal(theSignal);
	if (signalId < 0) {
		if (((QObject *)ti)->property(QTC_PROP).isValid()) {
			signalId = signalIndices.value(theSignal, -1);
			if (signalId < 0) {
				QObject * tp = (QObject *)(((QObject *)ti)->parent());
				int tsi = tp->metaObject()->indexOfSignal(theSignal);
				if (tsi >= 0) {
					ti = tp;
					signalId = tsi;
				}
				else {
					return false;
				}
			}
			else {
				signalId += metaObject()->methodCount();
			}
		}
		else {
			return false;
		}
	}
	return QMetaObject::disconnect(ti, signalId, NULL, -1);
}

bool DynamicQObject::disconnectDynamicSlot()
{
	QObject * ti = (QObject *)this;
	bool tb = QMetaObject::disconnect(ti, -1, NULL, -1);
	if (((QObject *)ti)->property(QTC_PROP).isValid()) {
		ti = (QObject *)(((QObject *)ti)->parent());
		tb |= QMetaObject::disconnect(ti, -1, NULL, -1);
	}
	return tb;
}

void DynamicQObject::freeDynamicSlots()
{
	QHashIterator<QByteArray, int> iter(slotIndices);
	while (iter.hasNext())
	{
		iter.next();
		slotList[ssList[iter.value()]]->free(iter.value());
	}
}


